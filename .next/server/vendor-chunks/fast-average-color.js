"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-average-color";
exports.ids = ["vendor-chunks/fast-average-color"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-average-color/dist/index.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/fast-average-color/dist/index.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FastAverageColor: () => (/* binding */ FastAverageColor)\n/* harmony export */ });\n/*! Fast Average Color | Â© 2022 Denis Seleznev | MIT License | https://github.com/fast-average-color/fast-average-color */\nfunction toHex(num) {\n    var str = num.toString(16);\n    return str.length === 1 ? '0' + str : str;\n}\nfunction arrayToHex(arr) {\n    return '#' + arr.map(toHex).join('');\n}\nfunction isDark(color) {\n    // http://www.w3.org/TR/AERT#color-contrast\n    var result = (color[0] * 299 + color[1] * 587 + color[2] * 114) / 1000;\n    return result < 128;\n}\nfunction prepareIgnoredColor(color) {\n    if (!color) {\n        return [];\n    }\n    return isRGBArray(color) ? color : [color];\n}\nfunction isRGBArray(value) {\n    return Array.isArray(value[0]);\n}\nfunction isIgnoredColor(data, index, ignoredColor) {\n    for (var i = 0; i < ignoredColor.length; i++) {\n        if (isIgnoredColorAsNumbers(data, index, ignoredColor[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isIgnoredColorAsNumbers(data, index, ignoredColor) {\n    switch (ignoredColor.length) {\n        case 3:\n            // [red, green, blue]\n            if (isIgnoredRGBColor(data, index, ignoredColor)) {\n                return true;\n            }\n            break;\n        case 4:\n            // [red, green, blue, alpha]\n            if (isIgnoredRGBAColor(data, index, ignoredColor)) {\n                return true;\n            }\n            break;\n        case 5:\n            // [red, green, blue, alpha, threshold]\n            if (isIgnoredRGBAColorWithThreshold(data, index, ignoredColor)) {\n                return true;\n            }\n            break;\n        default:\n            return false;\n    }\n}\nfunction isIgnoredRGBColor(data, index, ignoredColor) {\n    // Ignore if the pixel are transparent.\n    if (data[index + 3] !== 255) {\n        return true;\n    }\n    if (data[index] === ignoredColor[0] &&\n        data[index + 1] === ignoredColor[1] &&\n        data[index + 2] === ignoredColor[2]) {\n        return true;\n    }\n    return false;\n}\nfunction isIgnoredRGBAColor(data, index, ignoredColor) {\n    if (data[index + 3] && ignoredColor[3]) {\n        return data[index] === ignoredColor[0] &&\n            data[index + 1] === ignoredColor[1] &&\n            data[index + 2] === ignoredColor[2] &&\n            data[index + 3] === ignoredColor[3];\n    }\n    // Ignore rgb components if the pixel are fully transparent.\n    return data[index + 3] === ignoredColor[3];\n}\nfunction inRange(colorComponent, ignoredColorComponent, value) {\n    return colorComponent >= (ignoredColorComponent - value) &&\n        colorComponent <= (ignoredColorComponent + value);\n}\nfunction isIgnoredRGBAColorWithThreshold(data, index, ignoredColor) {\n    var redIgnored = ignoredColor[0];\n    var greenIgnored = ignoredColor[1];\n    var blueIgnored = ignoredColor[2];\n    var alphaIgnored = ignoredColor[3];\n    var threshold = ignoredColor[4];\n    var alphaData = data[index + 3];\n    var alphaInRange = inRange(alphaData, alphaIgnored, threshold);\n    if (!alphaIgnored) {\n        return alphaInRange;\n    }\n    if (!alphaData && alphaInRange) {\n        return true;\n    }\n    if (inRange(data[index], redIgnored, threshold) &&\n        inRange(data[index + 1], greenIgnored, threshold) &&\n        inRange(data[index + 2], blueIgnored, threshold) &&\n        alphaInRange) {\n        return true;\n    }\n    return false;\n}\n\nfunction dominantAlgorithm(arr, len, options) {\n    var colorHash = {};\n    var divider = 24;\n    var ignoredColor = options.ignoredColor;\n    var step = options.step;\n    var max = [0, 0, 0, 0, 0];\n    for (var i = 0; i < len; i += step) {\n        var red = arr[i];\n        var green = arr[i + 1];\n        var blue = arr[i + 2];\n        var alpha = arr[i + 3];\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n        var key = Math.round(red / divider) + ',' +\n            Math.round(green / divider) + ',' +\n            Math.round(blue / divider);\n        if (colorHash[key]) {\n            colorHash[key] = [\n                colorHash[key][0] + red * alpha,\n                colorHash[key][1] + green * alpha,\n                colorHash[key][2] + blue * alpha,\n                colorHash[key][3] + alpha,\n                colorHash[key][4] + 1\n            ];\n        }\n        else {\n            colorHash[key] = [red * alpha, green * alpha, blue * alpha, alpha, 1];\n        }\n        if (max[4] < colorHash[key][4]) {\n            max = colorHash[key];\n        }\n    }\n    var redTotal = max[0];\n    var greenTotal = max[1];\n    var blueTotal = max[2];\n    var alphaTotal = max[3];\n    var count = max[4];\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction simpleAlgorithm(arr, len, options) {\n    var redTotal = 0;\n    var greenTotal = 0;\n    var blueTotal = 0;\n    var alphaTotal = 0;\n    var count = 0;\n    var ignoredColor = options.ignoredColor;\n    var step = options.step;\n    for (var i = 0; i < len; i += step) {\n        var alpha = arr[i + 3];\n        var red = arr[i] * alpha;\n        var green = arr[i + 1] * alpha;\n        var blue = arr[i + 2] * alpha;\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n        redTotal += red;\n        greenTotal += green;\n        blueTotal += blue;\n        alphaTotal += alpha;\n        count++;\n    }\n    return alphaTotal ? [\n        Math.round(redTotal / alphaTotal),\n        Math.round(greenTotal / alphaTotal),\n        Math.round(blueTotal / alphaTotal),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction sqrtAlgorithm(arr, len, options) {\n    var redTotal = 0;\n    var greenTotal = 0;\n    var blueTotal = 0;\n    var alphaTotal = 0;\n    var count = 0;\n    var ignoredColor = options.ignoredColor;\n    var step = options.step;\n    for (var i = 0; i < len; i += step) {\n        var red = arr[i];\n        var green = arr[i + 1];\n        var blue = arr[i + 2];\n        var alpha = arr[i + 3];\n        if (ignoredColor && isIgnoredColor(arr, i, ignoredColor)) {\n            continue;\n        }\n        redTotal += red * red * alpha;\n        greenTotal += green * green * alpha;\n        blueTotal += blue * blue * alpha;\n        alphaTotal += alpha;\n        count++;\n    }\n    return alphaTotal ? [\n        Math.round(Math.sqrt(redTotal / alphaTotal)),\n        Math.round(Math.sqrt(greenTotal / alphaTotal)),\n        Math.round(Math.sqrt(blueTotal / alphaTotal)),\n        Math.round(alphaTotal / count)\n    ] : options.defaultColor;\n}\n\nfunction getDefaultColor(options) {\n    return getOption(options, 'defaultColor', [0, 0, 0, 0]);\n}\nfunction getOption(options, name, defaultValue) {\n    return (options[name] === undefined ? defaultValue : options[name]);\n}\n\nvar MIN_SIZE = 10;\nvar MAX_SIZE = 100;\nfunction isSvg(filename) {\n    return filename.search(/\\.svg(\\?|$)/i) !== -1;\n}\nfunction getOriginalSize(resource) {\n    if (isInstanceOfHTMLImageElement(resource)) {\n        var width = resource.naturalWidth;\n        var height = resource.naturalHeight;\n        // For SVG images with only viewBox attribute\n        if (!resource.naturalWidth && isSvg(resource.src)) {\n            width = height = MAX_SIZE;\n        }\n        return {\n            width: width,\n            height: height,\n        };\n    }\n    if (isInstanceOfHTMLVideoElement(resource)) {\n        return {\n            width: resource.videoWidth,\n            height: resource.videoHeight\n        };\n    }\n    return {\n        width: resource.width,\n        height: resource.height\n    };\n}\nfunction getSrc(resource) {\n    if (isInstanceOfHTMLCanvasElement(resource)) {\n        return 'canvas';\n    }\n    if (isInstanceOfOffscreenCanvas(resource)) {\n        return 'offscreencanvas';\n    }\n    if (isInstanceOfImageBitmap(resource)) {\n        return 'imagebitmap';\n    }\n    return resource.src;\n}\nfunction isInstanceOfHTMLImageElement(resource) {\n    return typeof HTMLImageElement !== 'undefined' && resource instanceof HTMLImageElement;\n}\nvar hasOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\nfunction isInstanceOfOffscreenCanvas(resource) {\n    return hasOffscreenCanvas && resource instanceof OffscreenCanvas;\n}\nfunction isInstanceOfHTMLVideoElement(resource) {\n    return typeof HTMLVideoElement !== 'undefined' && resource instanceof HTMLVideoElement;\n}\nfunction isInstanceOfHTMLCanvasElement(resource) {\n    return typeof HTMLCanvasElement !== 'undefined' && resource instanceof HTMLCanvasElement;\n}\nfunction isInstanceOfImageBitmap(resource) {\n    return typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap;\n}\nfunction prepareSizeAndPosition(originalSize, options) {\n    var srcLeft = getOption(options, 'left', 0);\n    var srcTop = getOption(options, 'top', 0);\n    var srcWidth = getOption(options, 'width', originalSize.width);\n    var srcHeight = getOption(options, 'height', originalSize.height);\n    var destWidth = srcWidth;\n    var destHeight = srcHeight;\n    if (options.mode === 'precision') {\n        return {\n            srcLeft: srcLeft,\n            srcTop: srcTop,\n            srcWidth: srcWidth,\n            srcHeight: srcHeight,\n            destWidth: destWidth,\n            destHeight: destHeight\n        };\n    }\n    var factor;\n    if (srcWidth > srcHeight) {\n        factor = srcWidth / srcHeight;\n        destWidth = MAX_SIZE;\n        destHeight = Math.round(destWidth / factor);\n    }\n    else {\n        factor = srcHeight / srcWidth;\n        destHeight = MAX_SIZE;\n        destWidth = Math.round(destHeight / factor);\n    }\n    if (destWidth > srcWidth || destHeight > srcHeight ||\n        destWidth < MIN_SIZE || destHeight < MIN_SIZE) {\n        destWidth = srcWidth;\n        destHeight = srcHeight;\n    }\n    return {\n        srcLeft: srcLeft,\n        srcTop: srcTop,\n        srcWidth: srcWidth,\n        srcHeight: srcHeight,\n        destWidth: destWidth,\n        destHeight: destHeight\n    };\n}\nvar isWebWorkers = typeof window === 'undefined';\nfunction makeCanvas() {\n    if (isWebWorkers) {\n        return hasOffscreenCanvas ? new OffscreenCanvas(1, 1) : null;\n    }\n    return document.createElement('canvas');\n}\n\nvar ERROR_PREFIX = 'FastAverageColor: ';\nfunction getError(message) {\n    return Error(ERROR_PREFIX + message);\n}\nfunction outputError(error, silent) {\n    if (!silent) {\n        console.error(error);\n    }\n}\n\nvar FastAverageColor = /** @class */ (function () {\n    function FastAverageColor() {\n        this.canvas = null;\n        this.ctx = null;\n    }\n    /**\n     * Get asynchronously the average color from not loaded image.\n     */\n    FastAverageColor.prototype.getColorAsync = function (resource, options) {\n        if (!resource) {\n            return Promise.reject(getError('call .getColorAsync() without resource.'));\n        }\n        if (typeof resource === 'string') {\n            // Web workers\n            if (typeof Image === 'undefined') {\n                return Promise.reject(getError('resource as string is not supported in this environment'));\n            }\n            var img = new Image();\n            img.crossOrigin = options && options.crossOrigin || '';\n            img.src = resource;\n            return this.bindImageEvents(img, options);\n        }\n        else if (isInstanceOfHTMLImageElement(resource) && !resource.complete) {\n            return this.bindImageEvents(resource, options);\n        }\n        else {\n            var result = this.getColor(resource, options);\n            return result.error ? Promise.reject(result.error) : Promise.resolve(result);\n        }\n    };\n    /**\n     * Get the average color from images, videos and canvas.\n     */\n    FastAverageColor.prototype.getColor = function (resource, options) {\n        options = options || {};\n        var defaultColor = getDefaultColor(options);\n        if (!resource) {\n            var error = getError('call .getColor(null) without resource');\n            outputError(error, options.silent);\n            return this.prepareResult(defaultColor, error);\n        }\n        var originalSize = getOriginalSize(resource);\n        var size = prepareSizeAndPosition(originalSize, options);\n        if (!size.srcWidth || !size.srcHeight || !size.destWidth || !size.destHeight) {\n            var error = getError(\"incorrect sizes for resource \\\"\".concat(getSrc(resource), \"\\\"\"));\n            outputError(error, options.silent);\n            return this.prepareResult(defaultColor, error);\n        }\n        if (!this.canvas) {\n            this.canvas = makeCanvas();\n            if (!this.canvas) {\n                var error = getError('OffscreenCanvas is not supported in this browser');\n                outputError(error, options.silent);\n                return this.prepareResult(defaultColor, error);\n            }\n        }\n        if (!this.ctx) {\n            this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n            if (!this.ctx) {\n                var error = getError('Canvas Context 2D is not supported in this browser');\n                outputError(error, options.silent);\n                return this.prepareResult(defaultColor);\n            }\n            this.ctx.imageSmoothingEnabled = false;\n        }\n        this.canvas.width = size.destWidth;\n        this.canvas.height = size.destHeight;\n        try {\n            this.ctx.clearRect(0, 0, size.destWidth, size.destHeight);\n            this.ctx.drawImage(resource, size.srcLeft, size.srcTop, size.srcWidth, size.srcHeight, 0, 0, size.destWidth, size.destHeight);\n            var bitmapData = this.ctx.getImageData(0, 0, size.destWidth, size.destHeight).data;\n            return this.prepareResult(this.getColorFromArray4(bitmapData, options));\n        }\n        catch (originalError) {\n            var error = getError(\"security error (CORS) for resource \".concat(getSrc(resource), \".\\nDetails: https://developer.mozilla.org/en/docs/Web/HTML/CORS_enabled_image\"));\n            outputError(error, options.silent);\n            !options.silent && console.error(originalError);\n            return this.prepareResult(defaultColor, error);\n        }\n    };\n    /**\n     * Get the average color from a array when 1 pixel is 4 bytes.\n     */\n    FastAverageColor.prototype.getColorFromArray4 = function (arr, options) {\n        options = options || {};\n        var bytesPerPixel = 4;\n        var arrLength = arr.length;\n        var defaultColor = getDefaultColor(options);\n        if (arrLength < bytesPerPixel) {\n            return defaultColor;\n        }\n        var len = arrLength - arrLength % bytesPerPixel;\n        var step = (options.step || 1) * bytesPerPixel;\n        var algorithm;\n        switch (options.algorithm || 'sqrt') {\n            case 'simple':\n                algorithm = simpleAlgorithm;\n                break;\n            case 'sqrt':\n                algorithm = sqrtAlgorithm;\n                break;\n            case 'dominant':\n                algorithm = dominantAlgorithm;\n                break;\n            default:\n                throw getError(\"\".concat(options.algorithm, \" is unknown algorithm\"));\n        }\n        return algorithm(arr, len, {\n            defaultColor: defaultColor,\n            ignoredColor: prepareIgnoredColor(options.ignoredColor),\n            step: step\n        });\n    };\n    /**\n     * Get color data from value ([r, g, b, a]).\n     */\n    FastAverageColor.prototype.prepareResult = function (value, error) {\n        var rgb = value.slice(0, 3);\n        var rgba = [value[0], value[1], value[2], value[3] / 255];\n        var isDarkColor = isDark(value);\n        return {\n            value: [value[0], value[1], value[2], value[3]],\n            rgb: 'rgb(' + rgb.join(',') + ')',\n            rgba: 'rgba(' + rgba.join(',') + ')',\n            hex: arrayToHex(rgb),\n            hexa: arrayToHex(value),\n            isDark: isDarkColor,\n            isLight: !isDarkColor,\n            error: error,\n        };\n    };\n    /**\n     * Destroy the instance.\n     */\n    FastAverageColor.prototype.destroy = function () {\n        if (this.canvas) {\n            this.canvas.width = 1;\n            this.canvas.height = 1;\n            this.canvas = null;\n        }\n        this.ctx = null;\n    };\n    FastAverageColor.prototype.bindImageEvents = function (resource, options) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var onload = function () {\n                unbindEvents();\n                var result = _this.getColor(resource, options);\n                if (result.error) {\n                    reject(result.error);\n                }\n                else {\n                    resolve(result);\n                }\n            };\n            var onerror = function () {\n                unbindEvents();\n                reject(getError(\"Error loading image \\\"\".concat(resource.src, \"\\\".\")));\n            };\n            var onabort = function () {\n                unbindEvents();\n                reject(getError(\"Image \\\"\".concat(resource.src, \"\\\" loading aborted\")));\n            };\n            var unbindEvents = function () {\n                resource.removeEventListener('load', onload);\n                resource.removeEventListener('error', onerror);\n                resource.removeEventListener('abort', onabort);\n            };\n            resource.addEventListener('load', onload);\n            resource.addEventListener('error', onerror);\n            resource.addEventListener('abort', onabort);\n        });\n    };\n    return FastAverageColor;\n}());\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1hdmVyYWdlLWNvbG9yL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwwQkFBMEI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2Zhc3QtYXZlcmFnZS1jb2xvci9kaXN0L2luZGV4LmVzbS5qcz9hMWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBGYXN0IEF2ZXJhZ2UgQ29sb3IgfCDCqSAyMDIyIERlbmlzIFNlbGV6bmV2IHwgTUlUIExpY2Vuc2UgfCBodHRwczovL2dpdGh1Yi5jb20vZmFzdC1hdmVyYWdlLWNvbG9yL2Zhc3QtYXZlcmFnZS1jb2xvciAqL1xuZnVuY3Rpb24gdG9IZXgobnVtKSB7XG4gICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDEgPyAnMCcgKyBzdHIgOiBzdHI7XG59XG5mdW5jdGlvbiBhcnJheVRvSGV4KGFycikge1xuICAgIHJldHVybiAnIycgKyBhcnIubWFwKHRvSGV4KS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGlzRGFyayhjb2xvcikge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0FFUlQjY29sb3ItY29udHJhc3RcbiAgICB2YXIgcmVzdWx0ID0gKGNvbG9yWzBdICogMjk5ICsgY29sb3JbMV0gKiA1ODcgKyBjb2xvclsyXSAqIDExNCkgLyAxMDAwO1xuICAgIHJldHVybiByZXN1bHQgPCAxMjg7XG59XG5mdW5jdGlvbiBwcmVwYXJlSWdub3JlZENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBpc1JHQkFycmF5KGNvbG9yKSA/IGNvbG9yIDogW2NvbG9yXTtcbn1cbmZ1bmN0aW9uIGlzUkdCQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZVswXSk7XG59XG5mdW5jdGlvbiBpc0lnbm9yZWRDb2xvcihkYXRhLCBpbmRleCwgaWdub3JlZENvbG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZ25vcmVkQ29sb3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzSWdub3JlZENvbG9yQXNOdW1iZXJzKGRhdGEsIGluZGV4LCBpZ25vcmVkQ29sb3JbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lnbm9yZWRDb2xvckFzTnVtYmVycyhkYXRhLCBpbmRleCwgaWdub3JlZENvbG9yKSB7XG4gICAgc3dpdGNoIChpZ25vcmVkQ29sb3IubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIC8vIFtyZWQsIGdyZWVuLCBibHVlXVxuICAgICAgICAgICAgaWYgKGlzSWdub3JlZFJHQkNvbG9yKGRhdGEsIGluZGV4LCBpZ25vcmVkQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgLy8gW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXVxuICAgICAgICAgICAgaWYgKGlzSWdub3JlZFJHQkFDb2xvcihkYXRhLCBpbmRleCwgaWdub3JlZENvbG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIC8vIFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSwgdGhyZXNob2xkXVxuICAgICAgICAgICAgaWYgKGlzSWdub3JlZFJHQkFDb2xvcldpdGhUaHJlc2hvbGQoZGF0YSwgaW5kZXgsIGlnbm9yZWRDb2xvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSWdub3JlZFJHQkNvbG9yKGRhdGEsIGluZGV4LCBpZ25vcmVkQ29sb3IpIHtcbiAgICAvLyBJZ25vcmUgaWYgdGhlIHBpeGVsIGFyZSB0cmFuc3BhcmVudC5cbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkYXRhW2luZGV4XSA9PT0gaWdub3JlZENvbG9yWzBdICYmXG4gICAgICAgIGRhdGFbaW5kZXggKyAxXSA9PT0gaWdub3JlZENvbG9yWzFdICYmXG4gICAgICAgIGRhdGFbaW5kZXggKyAyXSA9PT0gaWdub3JlZENvbG9yWzJdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lnbm9yZWRSR0JBQ29sb3IoZGF0YSwgaW5kZXgsIGlnbm9yZWRDb2xvcikge1xuICAgIGlmIChkYXRhW2luZGV4ICsgM10gJiYgaWdub3JlZENvbG9yWzNdKSB7XG4gICAgICAgIHJldHVybiBkYXRhW2luZGV4XSA9PT0gaWdub3JlZENvbG9yWzBdICYmXG4gICAgICAgICAgICBkYXRhW2luZGV4ICsgMV0gPT09IGlnbm9yZWRDb2xvclsxXSAmJlxuICAgICAgICAgICAgZGF0YVtpbmRleCArIDJdID09PSBpZ25vcmVkQ29sb3JbMl0gJiZcbiAgICAgICAgICAgIGRhdGFbaW5kZXggKyAzXSA9PT0gaWdub3JlZENvbG9yWzNdO1xuICAgIH1cbiAgICAvLyBJZ25vcmUgcmdiIGNvbXBvbmVudHMgaWYgdGhlIHBpeGVsIGFyZSBmdWxseSB0cmFuc3BhcmVudC5cbiAgICByZXR1cm4gZGF0YVtpbmRleCArIDNdID09PSBpZ25vcmVkQ29sb3JbM107XG59XG5mdW5jdGlvbiBpblJhbmdlKGNvbG9yQ29tcG9uZW50LCBpZ25vcmVkQ29sb3JDb21wb25lbnQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbG9yQ29tcG9uZW50ID49IChpZ25vcmVkQ29sb3JDb21wb25lbnQgLSB2YWx1ZSkgJiZcbiAgICAgICAgY29sb3JDb21wb25lbnQgPD0gKGlnbm9yZWRDb2xvckNvbXBvbmVudCArIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzSWdub3JlZFJHQkFDb2xvcldpdGhUaHJlc2hvbGQoZGF0YSwgaW5kZXgsIGlnbm9yZWRDb2xvcikge1xuICAgIHZhciByZWRJZ25vcmVkID0gaWdub3JlZENvbG9yWzBdO1xuICAgIHZhciBncmVlbklnbm9yZWQgPSBpZ25vcmVkQ29sb3JbMV07XG4gICAgdmFyIGJsdWVJZ25vcmVkID0gaWdub3JlZENvbG9yWzJdO1xuICAgIHZhciBhbHBoYUlnbm9yZWQgPSBpZ25vcmVkQ29sb3JbM107XG4gICAgdmFyIHRocmVzaG9sZCA9IGlnbm9yZWRDb2xvcls0XTtcbiAgICB2YXIgYWxwaGFEYXRhID0gZGF0YVtpbmRleCArIDNdO1xuICAgIHZhciBhbHBoYUluUmFuZ2UgPSBpblJhbmdlKGFscGhhRGF0YSwgYWxwaGFJZ25vcmVkLCB0aHJlc2hvbGQpO1xuICAgIGlmICghYWxwaGFJZ25vcmVkKSB7XG4gICAgICAgIHJldHVybiBhbHBoYUluUmFuZ2U7XG4gICAgfVxuICAgIGlmICghYWxwaGFEYXRhICYmIGFscGhhSW5SYW5nZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGluUmFuZ2UoZGF0YVtpbmRleF0sIHJlZElnbm9yZWQsIHRocmVzaG9sZCkgJiZcbiAgICAgICAgaW5SYW5nZShkYXRhW2luZGV4ICsgMV0sIGdyZWVuSWdub3JlZCwgdGhyZXNob2xkKSAmJlxuICAgICAgICBpblJhbmdlKGRhdGFbaW5kZXggKyAyXSwgYmx1ZUlnbm9yZWQsIHRocmVzaG9sZCkgJiZcbiAgICAgICAgYWxwaGFJblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRvbWluYW50QWxnb3JpdGhtKGFyciwgbGVuLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbG9ySGFzaCA9IHt9O1xuICAgIHZhciBkaXZpZGVyID0gMjQ7XG4gICAgdmFyIGlnbm9yZWRDb2xvciA9IG9wdGlvbnMuaWdub3JlZENvbG9yO1xuICAgIHZhciBzdGVwID0gb3B0aW9ucy5zdGVwO1xuICAgIHZhciBtYXggPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gc3RlcCkge1xuICAgICAgICB2YXIgcmVkID0gYXJyW2ldO1xuICAgICAgICB2YXIgZ3JlZW4gPSBhcnJbaSArIDFdO1xuICAgICAgICB2YXIgYmx1ZSA9IGFycltpICsgMl07XG4gICAgICAgIHZhciBhbHBoYSA9IGFycltpICsgM107XG4gICAgICAgIGlmIChpZ25vcmVkQ29sb3IgJiYgaXNJZ25vcmVkQ29sb3IoYXJyLCBpLCBpZ25vcmVkQ29sb3IpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gTWF0aC5yb3VuZChyZWQgLyBkaXZpZGVyKSArICcsJyArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGdyZWVuIC8gZGl2aWRlcikgKyAnLCcgK1xuICAgICAgICAgICAgTWF0aC5yb3VuZChibHVlIC8gZGl2aWRlcik7XG4gICAgICAgIGlmIChjb2xvckhhc2hba2V5XSkge1xuICAgICAgICAgICAgY29sb3JIYXNoW2tleV0gPSBbXG4gICAgICAgICAgICAgICAgY29sb3JIYXNoW2tleV1bMF0gKyByZWQgKiBhbHBoYSxcbiAgICAgICAgICAgICAgICBjb2xvckhhc2hba2V5XVsxXSArIGdyZWVuICogYWxwaGEsXG4gICAgICAgICAgICAgICAgY29sb3JIYXNoW2tleV1bMl0gKyBibHVlICogYWxwaGEsXG4gICAgICAgICAgICAgICAgY29sb3JIYXNoW2tleV1bM10gKyBhbHBoYSxcbiAgICAgICAgICAgICAgICBjb2xvckhhc2hba2V5XVs0XSArIDFcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvckhhc2hba2V5XSA9IFtyZWQgKiBhbHBoYSwgZ3JlZW4gKiBhbHBoYSwgYmx1ZSAqIGFscGhhLCBhbHBoYSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFs0XSA8IGNvbG9ySGFzaFtrZXldWzRdKSB7XG4gICAgICAgICAgICBtYXggPSBjb2xvckhhc2hba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVkVG90YWwgPSBtYXhbMF07XG4gICAgdmFyIGdyZWVuVG90YWwgPSBtYXhbMV07XG4gICAgdmFyIGJsdWVUb3RhbCA9IG1heFsyXTtcbiAgICB2YXIgYWxwaGFUb3RhbCA9IG1heFszXTtcbiAgICB2YXIgY291bnQgPSBtYXhbNF07XG4gICAgcmV0dXJuIGFscGhhVG90YWwgPyBbXG4gICAgICAgIE1hdGgucm91bmQocmVkVG90YWwgLyBhbHBoYVRvdGFsKSxcbiAgICAgICAgTWF0aC5yb3VuZChncmVlblRvdGFsIC8gYWxwaGFUb3RhbCksXG4gICAgICAgIE1hdGgucm91bmQoYmx1ZVRvdGFsIC8gYWxwaGFUb3RhbCksXG4gICAgICAgIE1hdGgucm91bmQoYWxwaGFUb3RhbCAvIGNvdW50KVxuICAgIF0gOiBvcHRpb25zLmRlZmF1bHRDb2xvcjtcbn1cblxuZnVuY3Rpb24gc2ltcGxlQWxnb3JpdGhtKGFyciwgbGVuLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlZFRvdGFsID0gMDtcbiAgICB2YXIgZ3JlZW5Ub3RhbCA9IDA7XG4gICAgdmFyIGJsdWVUb3RhbCA9IDA7XG4gICAgdmFyIGFscGhhVG90YWwgPSAwO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGlnbm9yZWRDb2xvciA9IG9wdGlvbnMuaWdub3JlZENvbG9yO1xuICAgIHZhciBzdGVwID0gb3B0aW9ucy5zdGVwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IHN0ZXApIHtcbiAgICAgICAgdmFyIGFscGhhID0gYXJyW2kgKyAzXTtcbiAgICAgICAgdmFyIHJlZCA9IGFycltpXSAqIGFscGhhO1xuICAgICAgICB2YXIgZ3JlZW4gPSBhcnJbaSArIDFdICogYWxwaGE7XG4gICAgICAgIHZhciBibHVlID0gYXJyW2kgKyAyXSAqIGFscGhhO1xuICAgICAgICBpZiAoaWdub3JlZENvbG9yICYmIGlzSWdub3JlZENvbG9yKGFyciwgaSwgaWdub3JlZENvbG9yKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVkVG90YWwgKz0gcmVkO1xuICAgICAgICBncmVlblRvdGFsICs9IGdyZWVuO1xuICAgICAgICBibHVlVG90YWwgKz0gYmx1ZTtcbiAgICAgICAgYWxwaGFUb3RhbCArPSBhbHBoYTtcbiAgICAgICAgY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIGFscGhhVG90YWwgPyBbXG4gICAgICAgIE1hdGgucm91bmQocmVkVG90YWwgLyBhbHBoYVRvdGFsKSxcbiAgICAgICAgTWF0aC5yb3VuZChncmVlblRvdGFsIC8gYWxwaGFUb3RhbCksXG4gICAgICAgIE1hdGgucm91bmQoYmx1ZVRvdGFsIC8gYWxwaGFUb3RhbCksXG4gICAgICAgIE1hdGgucm91bmQoYWxwaGFUb3RhbCAvIGNvdW50KVxuICAgIF0gOiBvcHRpb25zLmRlZmF1bHRDb2xvcjtcbn1cblxuZnVuY3Rpb24gc3FydEFsZ29yaXRobShhcnIsIGxlbiwgb3B0aW9ucykge1xuICAgIHZhciByZWRUb3RhbCA9IDA7XG4gICAgdmFyIGdyZWVuVG90YWwgPSAwO1xuICAgIHZhciBibHVlVG90YWwgPSAwO1xuICAgIHZhciBhbHBoYVRvdGFsID0gMDtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBpZ25vcmVkQ29sb3IgPSBvcHRpb25zLmlnbm9yZWRDb2xvcjtcbiAgICB2YXIgc3RlcCA9IG9wdGlvbnMuc3RlcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICAgIHZhciByZWQgPSBhcnJbaV07XG4gICAgICAgIHZhciBncmVlbiA9IGFycltpICsgMV07XG4gICAgICAgIHZhciBibHVlID0gYXJyW2kgKyAyXTtcbiAgICAgICAgdmFyIGFscGhhID0gYXJyW2kgKyAzXTtcbiAgICAgICAgaWYgKGlnbm9yZWRDb2xvciAmJiBpc0lnbm9yZWRDb2xvcihhcnIsIGksIGlnbm9yZWRDb2xvcikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlZFRvdGFsICs9IHJlZCAqIHJlZCAqIGFscGhhO1xuICAgICAgICBncmVlblRvdGFsICs9IGdyZWVuICogZ3JlZW4gKiBhbHBoYTtcbiAgICAgICAgYmx1ZVRvdGFsICs9IGJsdWUgKiBibHVlICogYWxwaGE7XG4gICAgICAgIGFscGhhVG90YWwgKz0gYWxwaGE7XG4gICAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBhbHBoYVRvdGFsID8gW1xuICAgICAgICBNYXRoLnJvdW5kKE1hdGguc3FydChyZWRUb3RhbCAvIGFscGhhVG90YWwpKSxcbiAgICAgICAgTWF0aC5yb3VuZChNYXRoLnNxcnQoZ3JlZW5Ub3RhbCAvIGFscGhhVG90YWwpKSxcbiAgICAgICAgTWF0aC5yb3VuZChNYXRoLnNxcnQoYmx1ZVRvdGFsIC8gYWxwaGFUb3RhbCkpLFxuICAgICAgICBNYXRoLnJvdW5kKGFscGhhVG90YWwgLyBjb3VudClcbiAgICBdIDogb3B0aW9ucy5kZWZhdWx0Q29sb3I7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRDb2xvcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldE9wdGlvbihvcHRpb25zLCAnZGVmYXVsdENvbG9yJywgWzAsIDAsIDAsIDBdKTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbihvcHRpb25zLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gKG9wdGlvbnNbbmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IG9wdGlvbnNbbmFtZV0pO1xufVxuXG52YXIgTUlOX1NJWkUgPSAxMDtcbnZhciBNQVhfU0laRSA9IDEwMDtcbmZ1bmN0aW9uIGlzU3ZnKGZpbGVuYW1lKSB7XG4gICAgcmV0dXJuIGZpbGVuYW1lLnNlYXJjaCgvXFwuc3ZnKFxcP3wkKS9pKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5hbFNpemUocmVzb3VyY2UpIHtcbiAgICBpZiAoaXNJbnN0YW5jZU9mSFRNTEltYWdlRWxlbWVudChyZXNvdXJjZSkpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVzb3VyY2UubmF0dXJhbFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVzb3VyY2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgLy8gRm9yIFNWRyBpbWFnZXMgd2l0aCBvbmx5IHZpZXdCb3ggYXR0cmlidXRlXG4gICAgICAgIGlmICghcmVzb3VyY2UubmF0dXJhbFdpZHRoICYmIGlzU3ZnKHJlc291cmNlLnNyYykpIHtcbiAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ID0gTUFYX1NJWkU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNJbnN0YW5jZU9mSFRNTFZpZGVvRWxlbWVudChyZXNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiByZXNvdXJjZS52aWRlb1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByZXNvdXJjZS52aWRlb0hlaWdodFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcmVzb3VyY2Uud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVzb3VyY2UuaGVpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNyYyhyZXNvdXJjZSkge1xuICAgIGlmIChpc0luc3RhbmNlT2ZIVE1MQ2FudmFzRWxlbWVudChyZXNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuICdjYW52YXMnO1xuICAgIH1cbiAgICBpZiAoaXNJbnN0YW5jZU9mT2Zmc2NyZWVuQ2FudmFzKHJlc291cmNlKSkge1xuICAgICAgICByZXR1cm4gJ29mZnNjcmVlbmNhbnZhcyc7XG4gICAgfVxuICAgIGlmIChpc0luc3RhbmNlT2ZJbWFnZUJpdG1hcChyZXNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuICdpbWFnZWJpdG1hcCc7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZS5zcmM7XG59XG5mdW5jdGlvbiBpc0luc3RhbmNlT2ZIVE1MSW1hZ2VFbGVtZW50KHJlc291cmNlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ7XG59XG52YXIgaGFzT2Zmc2NyZWVuQ2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpc0luc3RhbmNlT2ZPZmZzY3JlZW5DYW52YXMocmVzb3VyY2UpIHtcbiAgICByZXR1cm4gaGFzT2Zmc2NyZWVuQ2FudmFzICYmIHJlc291cmNlIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzO1xufVxuZnVuY3Rpb24gaXNJbnN0YW5jZU9mSFRNTFZpZGVvRWxlbWVudChyZXNvdXJjZSkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNJbnN0YW5jZU9mSFRNTENhbnZhc0VsZW1lbnQocmVzb3VyY2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNJbnN0YW5jZU9mSW1hZ2VCaXRtYXAocmVzb3VyY2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNpemVBbmRQb3NpdGlvbihvcmlnaW5hbFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3JjTGVmdCA9IGdldE9wdGlvbihvcHRpb25zLCAnbGVmdCcsIDApO1xuICAgIHZhciBzcmNUb3AgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3RvcCcsIDApO1xuICAgIHZhciBzcmNXaWR0aCA9IGdldE9wdGlvbihvcHRpb25zLCAnd2lkdGgnLCBvcmlnaW5hbFNpemUud2lkdGgpO1xuICAgIHZhciBzcmNIZWlnaHQgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2hlaWdodCcsIG9yaWdpbmFsU2l6ZS5oZWlnaHQpO1xuICAgIHZhciBkZXN0V2lkdGggPSBzcmNXaWR0aDtcbiAgICB2YXIgZGVzdEhlaWdodCA9IHNyY0hlaWdodDtcbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSAncHJlY2lzaW9uJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjTGVmdDogc3JjTGVmdCxcbiAgICAgICAgICAgIHNyY1RvcDogc3JjVG9wLFxuICAgICAgICAgICAgc3JjV2lkdGg6IHNyY1dpZHRoLFxuICAgICAgICAgICAgc3JjSGVpZ2h0OiBzcmNIZWlnaHQsXG4gICAgICAgICAgICBkZXN0V2lkdGg6IGRlc3RXaWR0aCxcbiAgICAgICAgICAgIGRlc3RIZWlnaHQ6IGRlc3RIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGZhY3RvcjtcbiAgICBpZiAoc3JjV2lkdGggPiBzcmNIZWlnaHQpIHtcbiAgICAgICAgZmFjdG9yID0gc3JjV2lkdGggLyBzcmNIZWlnaHQ7XG4gICAgICAgIGRlc3RXaWR0aCA9IE1BWF9TSVpFO1xuICAgICAgICBkZXN0SGVpZ2h0ID0gTWF0aC5yb3VuZChkZXN0V2lkdGggLyBmYWN0b3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmFjdG9yID0gc3JjSGVpZ2h0IC8gc3JjV2lkdGg7XG4gICAgICAgIGRlc3RIZWlnaHQgPSBNQVhfU0laRTtcbiAgICAgICAgZGVzdFdpZHRoID0gTWF0aC5yb3VuZChkZXN0SGVpZ2h0IC8gZmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKGRlc3RXaWR0aCA+IHNyY1dpZHRoIHx8IGRlc3RIZWlnaHQgPiBzcmNIZWlnaHQgfHxcbiAgICAgICAgZGVzdFdpZHRoIDwgTUlOX1NJWkUgfHwgZGVzdEhlaWdodCA8IE1JTl9TSVpFKSB7XG4gICAgICAgIGRlc3RXaWR0aCA9IHNyY1dpZHRoO1xuICAgICAgICBkZXN0SGVpZ2h0ID0gc3JjSGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzcmNMZWZ0OiBzcmNMZWZ0LFxuICAgICAgICBzcmNUb3A6IHNyY1RvcCxcbiAgICAgICAgc3JjV2lkdGg6IHNyY1dpZHRoLFxuICAgICAgICBzcmNIZWlnaHQ6IHNyY0hlaWdodCxcbiAgICAgICAgZGVzdFdpZHRoOiBkZXN0V2lkdGgsXG4gICAgICAgIGRlc3RIZWlnaHQ6IGRlc3RIZWlnaHRcbiAgICB9O1xufVxudmFyIGlzV2ViV29ya2VycyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gbWFrZUNhbnZhcygpIHtcbiAgICBpZiAoaXNXZWJXb3JrZXJzKSB7XG4gICAgICAgIHJldHVybiBoYXNPZmZzY3JlZW5DYW52YXMgPyBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xufVxuXG52YXIgRVJST1JfUFJFRklYID0gJ0Zhc3RBdmVyYWdlQ29sb3I6ICc7XG5mdW5jdGlvbiBnZXRFcnJvcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIEVycm9yKEVSUk9SX1BSRUZJWCArIG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gb3V0cHV0RXJyb3IoZXJyb3IsIHNpbGVudCkge1xuICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cblxudmFyIEZhc3RBdmVyYWdlQ29sb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFzdEF2ZXJhZ2VDb2xvcigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhc3luY2hyb25vdXNseSB0aGUgYXZlcmFnZSBjb2xvciBmcm9tIG5vdCBsb2FkZWQgaW1hZ2UuXG4gICAgICovXG4gICAgRmFzdEF2ZXJhZ2VDb2xvci5wcm90b3R5cGUuZ2V0Q29sb3JBc3luYyA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZ2V0RXJyb3IoJ2NhbGwgLmdldENvbG9yQXN5bmMoKSB3aXRob3V0IHJlc291cmNlLicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gV2ViIHdvcmtlcnNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSW1hZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGdldEVycm9yKCdyZXNvdXJjZSBhcyBzdHJpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gb3B0aW9ucyAmJiBvcHRpb25zLmNyb3NzT3JpZ2luIHx8ICcnO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHJlc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZEltYWdlRXZlbnRzKGltZywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJbnN0YW5jZU9mSFRNTEltYWdlRWxlbWVudChyZXNvdXJjZSkgJiYgIXJlc291cmNlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kSW1hZ2VFdmVudHMocmVzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0Q29sb3IocmVzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5lcnJvciA/IFByb21pc2UucmVqZWN0KHJlc3VsdC5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdmVyYWdlIGNvbG9yIGZyb20gaW1hZ2VzLCB2aWRlb3MgYW5kIGNhbnZhcy5cbiAgICAgKi9cbiAgICBGYXN0QXZlcmFnZUNvbG9yLnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IGdldERlZmF1bHRDb2xvcihvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZ2V0RXJyb3IoJ2NhbGwgLmdldENvbG9yKG51bGwpIHdpdGhvdXQgcmVzb3VyY2UnKTtcbiAgICAgICAgICAgIG91dHB1dEVycm9yKGVycm9yLCBvcHRpb25zLnNpbGVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KGRlZmF1bHRDb2xvciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbFNpemUgPSBnZXRPcmlnaW5hbFNpemUocmVzb3VyY2UpO1xuICAgICAgICB2YXIgc2l6ZSA9IHByZXBhcmVTaXplQW5kUG9zaXRpb24ob3JpZ2luYWxTaXplLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFzaXplLnNyY1dpZHRoIHx8ICFzaXplLnNyY0hlaWdodCB8fCAhc2l6ZS5kZXN0V2lkdGggfHwgIXNpemUuZGVzdEhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZ2V0RXJyb3IoXCJpbmNvcnJlY3Qgc2l6ZXMgZm9yIHJlc291cmNlIFxcXCJcIi5jb25jYXQoZ2V0U3JjKHJlc291cmNlKSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgIG91dHB1dEVycm9yKGVycm9yLCBvcHRpb25zLnNpbGVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KGRlZmF1bHRDb2xvciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbWFrZUNhbnZhcygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGdldEVycm9yKCdPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICBvdXRwdXRFcnJvcihlcnJvciwgb3B0aW9ucy5zaWxlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXBhcmVSZXN1bHQoZGVmYXVsdENvbG9yLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmN0eCkge1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN0eCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGdldEVycm9yKCdDYW52YXMgQ29udGV4dCAyRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICAgICAgICAgIG91dHB1dEVycm9yKGVycm9yLCBvcHRpb25zLnNpbGVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChkZWZhdWx0Q29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBzaXplLmRlc3RXaWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gc2l6ZS5kZXN0SGVpZ2h0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHNpemUuZGVzdFdpZHRoLCBzaXplLmRlc3RIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHJlc291cmNlLCBzaXplLnNyY0xlZnQsIHNpemUuc3JjVG9wLCBzaXplLnNyY1dpZHRoLCBzaXplLnNyY0hlaWdodCwgMCwgMCwgc2l6ZS5kZXN0V2lkdGgsIHNpemUuZGVzdEhlaWdodCk7XG4gICAgICAgICAgICB2YXIgYml0bWFwRGF0YSA9IHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLmRlc3RXaWR0aCwgc2l6ZS5kZXN0SGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdCh0aGlzLmdldENvbG9yRnJvbUFycmF5NChiaXRtYXBEYXRhLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGdldEVycm9yKFwic2VjdXJpdHkgZXJyb3IgKENPUlMpIGZvciByZXNvdXJjZSBcIi5jb25jYXQoZ2V0U3JjKHJlc291cmNlKSwgXCIuXFxuRGV0YWlsczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2VcIikpO1xuICAgICAgICAgICAgb3V0cHV0RXJyb3IoZXJyb3IsIG9wdGlvbnMuc2lsZW50KTtcbiAgICAgICAgICAgICFvcHRpb25zLnNpbGVudCAmJiBjb25zb2xlLmVycm9yKG9yaWdpbmFsRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChkZWZhdWx0Q29sb3IsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdmVyYWdlIGNvbG9yIGZyb20gYSBhcnJheSB3aGVuIDEgcGl4ZWwgaXMgNCBieXRlcy5cbiAgICAgKi9cbiAgICBGYXN0QXZlcmFnZUNvbG9yLnByb3RvdHlwZS5nZXRDb2xvckZyb21BcnJheTQgPSBmdW5jdGlvbiAoYXJyLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgYnl0ZXNQZXJQaXhlbCA9IDQ7XG4gICAgICAgIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICB2YXIgZGVmYXVsdENvbG9yID0gZ2V0RGVmYXVsdENvbG9yKG9wdGlvbnMpO1xuICAgICAgICBpZiAoYXJyTGVuZ3RoIDwgYnl0ZXNQZXJQaXhlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gYXJyTGVuZ3RoIC0gYXJyTGVuZ3RoICUgYnl0ZXNQZXJQaXhlbDtcbiAgICAgICAgdmFyIHN0ZXAgPSAob3B0aW9ucy5zdGVwIHx8IDEpICogYnl0ZXNQZXJQaXhlbDtcbiAgICAgICAgdmFyIGFsZ29yaXRobTtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSB8fCAnc3FydCcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NpbXBsZSc6XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtID0gc2ltcGxlQWxnb3JpdGhtO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3FydCc6XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtID0gc3FydEFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvbWluYW50JzpcbiAgICAgICAgICAgICAgICBhbGdvcml0aG0gPSBkb21pbmFudEFsZ29yaXRobTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0RXJyb3IoXCJcIi5jb25jYXQob3B0aW9ucy5hbGdvcml0aG0sIFwiIGlzIHVua25vd24gYWxnb3JpdGhtXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxnb3JpdGhtKGFyciwgbGVuLCB7XG4gICAgICAgICAgICBkZWZhdWx0Q29sb3I6IGRlZmF1bHRDb2xvcixcbiAgICAgICAgICAgIGlnbm9yZWRDb2xvcjogcHJlcGFyZUlnbm9yZWRDb2xvcihvcHRpb25zLmlnbm9yZWRDb2xvciksXG4gICAgICAgICAgICBzdGVwOiBzdGVwXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGNvbG9yIGRhdGEgZnJvbSB2YWx1ZSAoW3IsIGcsIGIsIGFdKS5cbiAgICAgKi9cbiAgICBGYXN0QXZlcmFnZUNvbG9yLnByb3RvdHlwZS5wcmVwYXJlUmVzdWx0ID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcikge1xuICAgICAgICB2YXIgcmdiID0gdmFsdWUuc2xpY2UoMCwgMyk7XG4gICAgICAgIHZhciByZ2JhID0gW3ZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzNdIC8gMjU1XTtcbiAgICAgICAgdmFyIGlzRGFya0NvbG9yID0gaXNEYXJrKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBbdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM11dLFxuICAgICAgICAgICAgcmdiOiAncmdiKCcgKyByZ2Iuam9pbignLCcpICsgJyknLFxuICAgICAgICAgICAgcmdiYTogJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknLFxuICAgICAgICAgICAgaGV4OiBhcnJheVRvSGV4KHJnYiksXG4gICAgICAgICAgICBoZXhhOiBhcnJheVRvSGV4KHZhbHVlKSxcbiAgICAgICAgICAgIGlzRGFyazogaXNEYXJrQ29sb3IsXG4gICAgICAgICAgICBpc0xpZ2h0OiAhaXNEYXJrQ29sb3IsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBGYXN0QXZlcmFnZUNvbG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH07XG4gICAgRmFzdEF2ZXJhZ2VDb2xvci5wcm90b3R5cGUuYmluZEltYWdlRXZlbnRzID0gZnVuY3Rpb24gKHJlc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgb25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVuYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5nZXRDb2xvcihyZXNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdW5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGdldEVycm9yKFwiRXJyb3IgbG9hZGluZyBpbWFnZSBcXFwiXCIuY29uY2F0KHJlc291cmNlLnNyYywgXCJcXFwiLlwiKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHVuYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgICAgIHJlamVjdChnZXRFcnJvcihcIkltYWdlIFxcXCJcIi5jb25jYXQocmVzb3VyY2Uuc3JjLCBcIlxcXCIgbG9hZGluZyBhYm9ydGVkXCIpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHVuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25sb2FkKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25hYm9ydCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9ubG9hZCk7XG4gICAgICAgICAgICByZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmFzdEF2ZXJhZ2VDb2xvcjtcbn0oKSk7XG5cbmV4cG9ydCB7IEZhc3RBdmVyYWdlQ29sb3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-average-color/dist/index.esm.js\n");

/***/ })

};
;